#### 3강 (컴퓨터 시스템 구조와 운영체제의 상관관계, 시스템콜, 인터럽트 등..)
설명 쉽고 자세하게 해주셔서 이해하는데 도움 많이 됐다.
추후에 깔끔하게 정리할 필요가 있음

```
하드디스크는 여기있는 데이터를 읽어서 메모리로 읽어 들이기도 하고

처리결과를 파일시스템에 저장하기도 하죠
아웃풋 역할도 동시에 수행하는 장치가 되겠습니다

그리고 이러한 각각의 아이오디바이스들은 작은 씨피유같은 것들이 붙어있게 되니다
디바이스 컨트롤러라고 합니다

디스크에서 헤드가 어떻게 움직이고 그 내부를 통제하고 (씨피유의 역하ㅣ이 아니고 컨트롤러 역하임)

키보드 컨트롤러도 마찬가지죠

이 메인씨피유의 작업공간인 메인메모리가 있듯이
디바이스 컨트롤러들도 그들의 작업공간ㅇ ㅣ필요함니다

각각 존재하는데 로컬 버퍼라고 합니다.

메모리에 올라간게 운영체제인지 사용자 프로그램인지 구분해주는게 모드 빗이라는 겁니다.
인터럽트 라인이라는게 시피유에 붙어있는데 왜 있는거냐

씨피유는 항상 메모리에 있는 인스트럭션만 계속 실행합니다
정확하게 설명드리면 인스트럭션 하나 실행하면 다음번에 실행할 그 인스트럭션 기계어의 주소값이 이제 증가하고 그러면 다음 사이클ㅇ서는 그다음 인스트륵션 실행하고
그 역할만 계속하고있어요
키보드 입력 들어왔다던지 디스크에서 뭘 읽어왔다던지 뭘 읽어오려고 요청하는데 다 끝냈다던지
이거 시피유가 어케 아느냐
그거 전달하기 위해서 인터럽트 라인이 붙어있는거니다

시피유는 메모리하고만 일해요 읽어와서

제가 작성한 씨 프로그램 에이가 메모리에서 실행디ㅗ고 있다고 하면

이 프ㅗ그램이 시피유에서 인스트럭션 실행하다가 경우에 따라서는 스캔에프로 키보드 입력 받을수도 있구요
또 프로그램 시행하다가 디스크에서 파일을 읽어올수도 있고
항상 메모리에서만 작업을 하는게 아니라 그렇게 할 수 있는거죠

지금 말씀드린 키보드 입력이나 화면 출력 디스크 입출력 같은게 이 아이오디바이스를 접근하는 인스트럭션들이 되겠죠
그 씨피유는 직접 아이오 디바이스 접근하지 않고 메모리에서 읽어서 인스트럭션만 실행을 하게 되어있어요

그러다가 디스크에서 뭘 읽어오라는 요청을 어떻게 보내느냐

만약에 인스트럭션 쭉 수행하다가 디스크에서 뭐 읽어와야한다

이 친구(시퓨)가 디스크 접근하는게 아니라
디스크한테 읽어오라고 일을 시켜놓으면 디스크는 이제 요청한 데이터를 읽어오겠죠 컨트롤러 지시 받아서

이 작업은 굉장히 오래걸릴겁니다

디스크는 시킨일 하면서 로컬 버퍼에 읽어놓았다가

시피유는 아이오 컨트롤러한테 시키고 놀지 않고 메모리에 있는 인스트럭션 계속 실행하는겁니다

근데 보통 그 읽어온거 보고 다음꺼 실행하는게 프로그램의 역할이 되겠죠

(읽어온 결과 보고 그다음에 무슨일을 하는지가 결정이 되겠죠)

사용자가 키보드를 뚜드려서 뭔가 인풋이 들어오면 그때 나한테 알려달라고하고
얘는 키보드에서 입력이 들어오는지 안들어오는지 개의치않고
오래걸리는 작업이기 때문에..

본인이 할 수 있는 일을 계속 실행하는겁니다

그중에서는 이제 이 프로그램이 더이상 아이오 들어오는 데이타가 먼지를 모르고서는 더이상 실행이 안되겠다
그럼 시피유가 이제 다른 프로그램으로 넘어가게 되요
즉 이친구는 굉장히 빠른 일꾼인데 머 이쪽에ㅇ ㅘ서 이런 구경도 하고 살면 좋은데
그 빠른 속도를 이용해서 계속 일만 하는겁니다 (시피유)

그래서 인제 프로그램 여러개가 실행될때 시퓨는 아주 짧은시간 간격으로 왔다갔다하면서 처리가 되기 때문에
실제 사용자 입장에서 보면 굉장히 인터랙티브하게 응답해주는 그런식으로 보인다는거죠

그런데 이제 하나 문제가 있는데 만약에 이 프로그램이 제가 작성한 프로그램인데 무한 루프를 도는 프로그램을 만들 수 있겠죠 포문이나 와일문을 돌리면서
계속 시피유만 쓰는 중간에 아이오 작업 안하고 

이 프로그램한테 시피유가 한번 넘어가면 종료되지도 않고 그렇다고 아이오 하지도 않고 계속 시피유만 쓸수가 있을거에요

그럼 시피유가 다른 프로그램한테 넘어가지 못해서 시피유가 타임 쉐어링 구현할수가 없거든요

그래서 컴퓨터 안에는 이 타이머라는 하드웨어를 두고 있어요

이 타이머의 역할이 뭐냐면 특정 프로그램이 시피유를 독점하는것을 막기 위한겁니다
그래서 처음에는 이제 운영체제가 컴퓨터를 켰을때 운영체ㅔㅈ가 시피유를 가지고 있다가 여러 사용자 프로그램에게 시피유를 넘겨주죠
그냥 넘겨주는것이 아니라 타이머에다가 어떤 값을 세팅한다음에 사용자 프로그램한테 시피유 넘겨주게 됩니다
그럼 사용자 프로그램은 독점적으로 계속 쓸 수 있는게 아니라 여기 할당된 시간
수십~ 수백 밀리세컨드 수백도 안되겠네요

그 할당 시간만큼 실행하다가 타이머가 시피유한테 인터럽트 걸고 알려줘요
세팅시간 끝났다고 알려주게 되면 시피유는 매번 인스트럭션을 하나씩 실행하다가 그 인스트럭션이 하나 끝나고 나면 인터럽트 라인을 체크합니다
인터럽트 들어온게 없으면 다음꺼 실행하고
끝나면 또 라인 체크하고 반복해요

그래서 만야ㅣ에 타이머가 인터럽트 걸어왔으면 그러면 시피유는 하던일을 잠시 멈추고 그리고 이 시피유의 제어권이 사용자 프로그램으로 부터 운영체제로 자동으로 넘어가게 되어있어요

그래서 사용자 프로그램이 시피유를 넘겨 줄때는 자유롭지만 뺏을때는 자유가 아님니다

그래서 운영체제가 시피유를 얻게 되면 뭘 하느냐
이 친구는 한 100밀리세컨드만큼 썼기 때문에 다음 친구한테 시피유를 넘겨주죠
그냥 주는건 아니고 타이머에 값을 세팅해서 시피유 넘겨주죠

그럼 또 이 친구가 넘겨주다가 시간 만료되면타이머 인터럽트 들어오고 프로그램 제어권이 다시 오에스로 넘어가고

프로그램 n개 있으면 시피유가 차례대로 넘겨주다가 다시 처음으로 가고

여튼 타이머의 도움을 받아서 실행하고 있는것이죠

메모리에서 인스트럭션 실행하다가 프로그램 종료하면 자동으로 반납하게 되고

타임 쉐어링 구현하기 위해서 타이머가 있는거구요

뒤에 또 설ㅕ드리겠지만 사용자 프로그램은 본인이 직접 아이오 장치 접근할 수 있어요

그 모든 인스트럭션은 운영체ㅈ를 통해서 할수 있게 막아놨어요 ㅂ안등을 이유로

그래서 이 프로그램이 뭘 읽어와야된다거나 출력해야된다거나 하면

스스로 운영체제한테 요청하면
운영체제가 해당하는 작업을 시키는거죠

근데 오래걸리니까 운영체제가 지금 요청한애말고 다른 애한테 시피유 넘겨주게 되는거구요

그럼 얘네는 언제 다시 시피유를 얻게 되느냐 키보드에서 입력이 들어와야지 다음 처리를 할 수 있겠죠
언제까지 기다리느냐 하면 아이오 컨트롤러가 요청받은 작업이 끝나서 이게 자신의 버퍼에 들어왔다 그럼 아이오 컨트롤러가 시피유에 인터럽트를 걸게 됩니다
그럼 시피유 제어권이 운영체제한테 자연스럽게 넘어가게 됩니다

이제 그 버퍼에 들어있는 내용을 해당 프로그램이 올라와있는 메모리 공간에다가 카피해주고 그런다음에 방금전에 누군가가 시피유를 쓰다가 인터럽트를 당했으니까 일단은 그 친구한테 다시 시피유를 줍니다 그래서

그 친구한테 이제 한정된 시간이 남아있다고 하면 그 친구가 시피유를 더 쓰게 하고 그 친구한테 할당된 시간이 끝나고 언젠가는 이 키보드 입력이 들어와서 준비가 완료된 프로그램한테 시피유를 주게 되겠죠 라운드로빈으로 돌리면서 언젠가 그 친구 차례가 되면 시피유를 얻게 됩니다

- 모드빗
사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요

mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원
사용자 모드 : 사용자 프로그램 수행
모니터 모드 : OS 코드 수행
(모니터 모드는 커널 모드나 시스템 모드라고도 부를 수 있다)

보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 '특권명령'으로 규정

Interrupt Exception 발생시 하드웨어가 mode bit을 0으로 바꿈
사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 셋팅

- 타이머
정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴
타이머는 매 클럭 틱 때마다 1씩 감소
타이머 값이 0이 되면 타이머 인터럽트 발생
CPU를 특정 프로그램이 독점하는 것으로부터 보호

타이머는 time sharing을 구현하기 위해 널리 이용됨
타이머는 현재 시간을 계산하기 위해서도 사용

- 디바이스 컨트롤러
* I/O device controller
    해당 I/O 장치유형을 관리하는 일종의 작은 CPU
    제어 정보를 위해 control register, status register를 가짐
    local buffer를 가짐 (일종의 data register)
* I/O는 실제 device와 local buffer 사이에서 일어남
* Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림

device driver (장치구동기)
    OS 코드 중 각 장치별 처리루틴 -> software
device controller (장치제어기)
    각 장치를 통제하는 일종의 작은 CPU -> hardware



여기 보시면 사실 메모리를 전담하는 메모리 컨트롤러라는것도 있습니다
다른 디바이스랑 마찬가지로 붙어있고 그리고 이 메모리를 원칙적으로는 이제 CPU만 접근할 수 있게 그렇게 해놓은거죠
메인메모리는 CPU만 접근하고 이러한 아이오디바이스들은 자기 자신들의 로컬 버퍼가 존재하기 때문에
버퍼에다가 뭔가 데이터를 받아서 일을 하고 버퍼가 쌓이게되면 이제 씨피유가 거기있는 내용을 읽어서 자신의 그 작업영역인 메모리에 복사를하고

그리고 씨피유는 사실 메모리 접근도 할 수 있고 로컬 버퍼 접근도 할 수 있고 그렇게 되어있고

이러한 작은 씨피유 (디바이스에 달려있는거)는 자기 로컬 버퍼에만 접근 할 수 있고
원래 이렇게 정의가 되어있는겁니다

그렇게 하다보니까 씨피유가 너무 인터럽트를 많이 당해요 무슨 얘기냐 하면 지금 장치를 몇개냐 보여드렸습니다만

인터럽트 들어오면 여기있는 데이타 카피해오고 그러다가 씨피유가 일 쫌 할라고 하면 키보드 입력이 들어와서 인터럽트 걸고
그럼 또 시피유는 오에스로 넘어가서 거기 입력된 내용 카피해와야하고 그래서 별로 효율적이지 않다는거죠
그래서 이제 DMA라는 컨트롤러 디렉트 메모리 액세스
직접 메모리를 액세스 할 수 있는 컨트롤러입니다

메모리를 직접 접근할 수 있는 장치는 씨피유 뿐이었는데 DMA가 있으니 이제 DMA도 메모리를 접근할 수 있고 그렇게 되어있습니다

이제 둘이서 특정 메모리 동시에 접근하면 문제가 생길 수 있어서 메모리 컨트롤러는 그걸 중재하는 담당을 하고 있어요

일관성이 깨지면 안되기 때문에 교통정리하고 조율하는 역할을 메모리 컨트롤러가 하고 있구요

그럼 DMA가 왜 있냐? 씨피유 혼자쓰면 편한데... 그건 이제 씨피유가 인터럽트를 너무 많이 받아요 DMA 컨트롤러의 역할은 뭐냐면 중간에 이 친구들이 작업이 들어왔을때 그걸 씨피유한테 인터럽트를 걸어서 씨피유가 여기서 이걸 카피하게 하는건 오버헤드가 너무 크다는거에요

그래서 씨피유는 자기일을 하고 있고 로컬 버퍼에 중간에 들어오는게 작업이 끝났으면 DMA가 그걸 가져와서 메모리까지 복사하는일까지 해주는겁니다

그런다음에 씨피유한테 인터럽트 한번만 걸어서 이제 여기까지 처리됐습니다를 DMA가 보고해주고

그럼 씨피유가 중간에 인터럽트 당하는 빈도가 줄어들어서 이 빠른 장치를 좀 더 효율적으로 쓸 수가 있다는 것이죠

이 DMA라는 장치가 왜 필요한지 설명을 드렸구요

그다음에 이 중에서 디바이스 드라이버라는 용어가 있고 디바이스 컨트롤러라는 용어가 있는데 디바이스 컨트롤러는 이미 설명 드렸고(각 디바이스마다 전담하는 하드웨어 장치가 있는거라고.. 그걸 디바이스 컨트롤러라고 부르고)

근데 디바이스 드라이버는 SW를 의미합니다 운영체제에 있는 코드 중에서 각 디바이스를 처리하기 위해서 그 디바이스의 인터페이스가 있는데 그거에 맞게 접근할 수 있게 해주는 소프트웨어를 디바이스 드라이버라고 합니다

이제 우리가 이 하드웨어를 하나 붙이면 이제 그 디바이스 드라이버를 설치해줘야하는거고..

결국 씨피유의 숙명은 본인이 이번에 실행해야될 인스트럭션의 메모리 주소를 여기 레지스터중에서 프로그램카운터라는 PC라는 레지스터가 다음에 어디있는 인스트럭션을 실행시켜야되는지 그 주소를 가지고 있거든요
그래서 그 인스트럭션만 매번 실행하는게 씨피유의 운명이죠 그러고 이제 그 인스트럭션 중에서 이러한 아이오 장치를 접근해야되는 그런 상황이 되면 이제 디바이스드라이버를 통해서 이 친구한테 뭐 읽으라던지 쓰라던지 하는 명령을 하게 되는거구요
디바이스 드라이버가 이 디스크에서 실제 헤드를 움직여서 읽고 쓰게 하는 그런 코드는 아닙니다
디스크 컨트롤러가 그 코드에서 지시를 받아서 일을 하는거고
이제 디스크 안에 펌웨어라고 해가지고 이 친구를 동작하게 하기 위해서는 무슨 코드가 필요한지 그런게 있는데
얘가 실행하는 인스트럭션 코드는 따로 있어요

디바이스 드라이버는 이제 씨피유가 실행하는 이 장치를 수행하기 위해서 필요한 그런 코드를 담고 있는거라는거죠

그래서 이 친구는 직접 뭔가 일을 할수는 없고 그 매뉴얼이 있습니다 그 매뉴얼대로 일을하는겁니다
매뉴얼에 뭐가 적혀있는거냐면 매뉴얼에 이제 메모리 몇번지의 일을 하라는게 적혀있고 그럼 이 친구(CPU)는 그 인스트럭션을 실행하고 나면 이제 그 다음 매뉴얼의 다음 페이지에 있는 인스트럭션을 또 실행하고 요런 작업만 계속 반복하는거죠
스스로 뭔가 일하는것이 아니고.. 이 전체적인 통제를 운영체제가 하는것이죠

- 입출력(I/O)의 수행
* 모든 입출력 명령은 특권 명령
* 사용자 프로그램은 어떻게 I/O를 하는가?
    시스템콜(system call)
        사용자 프로그램은 운영체제에게 I/O 요청
    trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
    제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
    올바른 I/O 요청인지 확인 후 I/O 수행
    I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김


사용자 프로그램이 운영체제 커널 함수를 호출하는걸 시스템콜이라고 부르구요 이건 일반 함수 호출하고 다릅니다
시스템콜을 하면 사용자 프로그램이 소프트웨어적으로 직접 인터럽트 걸 수 있고 그러면 이제 모드빗이 0으로 바뀌고 처리를 합니다

- 인터럽트
* 인터럽트 당한 시점의 레지스터와 program counter를 세이브한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

* 넓은 의미로는 Interrupt라고 하고, 소프트웨어/하드웨어 인터럽트로 나뉨
    Interrupt (하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트
    Trap (소프트웨어 인터럽트)
        Exception : 프로그램이 오류를 범한 경우
        System call : 프로그램이 커널 함수를 호출하는 경우

* 인터럽트 관련 용어
    인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음
    인터럽트 처리 루틴 (Interrupt Service Routine, 인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수

* 현대의 운영체제는 인터럽트에 의해 구동됨


처음에는 사용자 프로그램이 I/O를 요청하기 위해서 시스템 콜을 하고 그러면 이제 OS가 I/O한테 일을 시키고 다른 프로그램한테 넘어갔을거고
시킨일이 다 끝나면 그때는 하드웨어 인터럽트가 걸리죠 일을 다했다고 알려주고
I/O를 하기 위해서 필요한 인터럽트는 소프트웨어냐? 하드웨어냐? 두가지 다 필요한거죠

CPU를 특정 프로그램이 독점하는걸 막기 위해서 타이머 인터럽트라는게 있구요



```
