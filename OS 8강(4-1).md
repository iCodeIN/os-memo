```

4장 프로세스 매니지먼트

* 프로세스 생성 (Process Creation)
- 부모 프로세스(Parent Process)가 자식 프로세스(Children Process) 생성
- 프로세스의 트리(계층 구조) 형성
- 프로세스는 자원을 필요로 함
    - 운영체제로부터 받는다
    - 부모와 공유한다
- 자원의 공유
    - 부모와 자식이 모든 자원을 공유하는 모델
    - 일부를 공유하는 모델
    - 전혀 공유하지 않는 모델
- 수행 (Execution)
    - 부모와 자식은 공존하며 수행되는 모델
    - 자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델

- 주소 공간(Address space)
    - 자식은 부모의 공간을 복사함 (binary and OS data)
    - 자식은 그 공간에 새로운 프로그램을 올림
- 유닉스의 예
    - fork() 시스템 콜이 새로운 프로세스를 생성
        - 부모를 그대로 복사 (OS data except PID + binary)
        - 주소 공간 할당
    - fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림

------------------------------------------

여러분들 프로세스가 어떻게 만들어지는가, 누가 프로세스를 만드느냐
여기보시면 답이 나와있죠 부모 프로세스가 자식 프로세스를 생성한다 이러케 되어있어요

사람도 이제 하늘에서 뚝떨어진 사람이 없고, 부모님이 있기 때문에 족보에 의해서 자식이 만들어졌듯이 프로세스의 세계도 마찬가지입니다
어떤 프로세스가 하나 있으면 그러면 그친구가 프로세스를 생성하게 되는데 이 생성하는 방법은 보통 복제생성을 하게 됩니다.

그거에 대해서는 뒤에서 설명 드리도록 하구요 프로세스는 부모가 자식을 만드는데 사람처럼 아버지와 어머니가 있는게 아니고
부모 프로세스는 하나입니다 parent process 하나가 자식을 그냥 복제해서 만드는거기 때문에.. 자식을 하나만 만들 수 있는건 아니고 여러개 만들 수 있어요

족보가 트리 형태로 구성이 되어요 부모 하나가 자식을 여럿 낳고 자식이 자식을 낳고...

프로세스가 실행이 될려면 자원이 필요하죠 보통 운영체제로부터 받게 되겠구요
자식이 부모 프로세스와 자원을 공유하는 경우도 있고, 공유하지 않는 경우도 있습니다
이 부분은 경우에 따라서 자원을 공유하는 모델도 있고 그렇지 않은 모델도 있다 원칙적으로는 공유하지 않습니다.
낳고난뒤로 별도의 프로세스이기 때문에 경쟁하는 사이고 각자 시피유를 서로 얻으려고 경쟁하고 메모리를 더 많이 받으려고 경쟁하지
그래서 공유하지 않는 모델이 일반적입니다

그리고 프로세스가 실행이 될때 부모와 자식이 공존하면서 실행되는 경우가 있고 자식을 하나 생성한다음에 자식이 종료될때까지 부모가 기다리는.. 여기서 웨이트라는건 블럭드 상태라는거죠
그렇게 기다리는 모델도 있습니다

여기에 대해서 더 자세히 설명드리자면 프로세스의 생성은 부모가 자식을 생성한다고 말씀드렸고 그럼 어떻게 생성을 하느냐,
복제 생성 한다고 말씀드렸죠 일단 부모 프로세스의 주소공간이 있을겁니다 그럼 주소공간을 자식 프로세스는 그대로 복사하게 됩니다
주소 공간을 복사하고 그 운영체제 있는 데이타들, 피씨비라던지 자원들 이런것도 똑같이 일단 복사를 하게 됩니다.

이렇게 복제 생성을 하게 되면은 컴퓨터안에 존재하는 모든 프로세스는 같은 일만 해야겠다.. 그렇게 하진 않고
복제를 한뒤에 그 복제한 곳에 새로운 프로그램을 덮어씌울 수 있습니다 그래서 서로 다른 프로그램이 이제 컴퓨터 내에 존재할 수 있게 되는것이죠
그래서 지금 복제생성을 한다고 말씀드린것이 fork라는 시스템 콜의 역할이 되구요 복제 생성을 한 다음에 다른 프로그램으로 덮어씌우는 것이 여기 나오는 exec() 라는 시스템 콜이 되겠습니다

그래서 프로세스 생성은 보통 2단계를 거치는데 하나는 부모 프로세스를 복제하는 단계고, 거기다가 새로 덮어씌우는 단계입니다.

이게 독립적이기 때문에 복제하고 덮어씌우지 않을수도 있고, 자식 프로세스를 만들지 않고 exec를 해버리면 완전히 새로운 프로세스로 바뀔 수도 있습니다.
예를 들어 제가 지금까지 열심히 살아왔는데, 지금까지 살아온게 맘에 안들면 다른 프로그램을 덮어씌워서 새로운 삶을 사는게 바로 exec이라는 시스템 콜입니다.

부모 프로세스가 자식 프로세스를 생성한다고 말씀드렸습니다만, 유저 프로그램이 직접 다른 프로세스를 생성하는건 아니구요 운영체제를 거쳐서 생성합니다. 여기서 설명한 fork나 exec가 시스템 콜이기 때문에, 운영체제한테 생성해달라고 요청하면 운영체제가 대신 낳아주는 그런 개념이 되겠습니다.

* 프로세스 종료 (Process Termination)
- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌 (exit)
    - 자식이 부모에게 output data를 보냄 (via wait)
    - 프로세스의 각종 자원들이 운영체제에게 반납됨
- 부모 프로세스가 자식의 수행을 종료시킴 (abort)
    - 자식이 할당 자원의 한계치를 넘어섬
    - 자식에게 할당된 태스크가 더 이상 필요하지 않음
    - 부모가 종료(exit) 하는 경우
        - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다
        - 단계적인 종료

--------------------------------------------------------

그다음에 프로세스가 종료 될 때, 보통은 인제 프로세스가 종료될때는 exit이라는 시스템 콜을 하면 프로세스가 종료가 됩니다
여러분이 그 씨언어로 프로그램을 작성했다고 하면, 메인 함수안에다가 뭔가 문장들을 쭉 써놓고 제일 마지막에 중괄호를 닫게 되죠
그럼 프로그래머가 명시적으로 엑싯 시스템콜을 하지 않아도 컴파일러가 중괄호 닫는 지점에 엑싯이라는 시스템콜을 넣어주게 됩니다

물론 여러분이 중간에 명시적으로 엑싯 시스템콜을 해서 종료시키게 할수도 있죠

이러ㄷㅎ게 프로세스가 종료가 될때는 자식이 부모한테 어떤 그 데이타를 보내게 됩니다
뭐 사람은 원래 부모가 더 일찍 돌아가시고 자식이 오래까지 살지만 프로세스의 세계에서는 항상 이 원칙이 있는데
부모 프로세스가 자식 프로세스를 낳아노으면 자식이 먼저 죽고 부모가 뒤치닥거리를 하는 구조입니다

프로세스가 종료될때는 부모한테 이제 뭔가 데이타ㄱ ㅏ전달이 되고 그게 이제 웨이트 시스템콜을 통해서 데이타를 전달하게 됩니다

그래서 자발적으로 스스로 프로세스가 종료될때는 엑싯 시스템콜을 해주며 ㄴ되겠고 이제 비 자발적으로 종료되는 경우가 있습니다

abort, 강제종료가 그런경우인데 어느 경우에 발생하느냐면

어떤 자원의 할당선을 넘어서는거죠 자식이 너무 펑펑쓰니까 부모가 안되겠다하고 강제로 죽이는 그런것이죠

그리고 일 시켜먹으러고 자식 프로세스를 만든건데 더이상 자식한테 시킬일이 없어요 그럼 부모 프로세스가 자식을 죽이는 경우가 있고
그다음에 세번째로 나와있는 경우는 그.. 부모 프로세스가 종료되는 경우에 아까도 말씀드렸지만 프로세스의 세계에서는 자식 프로세스가 먼저 종료된 다음에 부모 프로세스가 종료되어야 한다고 말씀드렸는데
어떻게 되다보니 부모 프로세스를 종료해야되는 상황이 생겼습니다 그럼 자식이 먼저 죽어야 하기 때문에 그 부모가 낳아놓은 모든 자식을 죽고 자기가 죽습니다

근데 자식들이 손자 낳아놓고 그런 경우가 있겠죠 그런 경우에는 단계적인 종료가 이루어질수 있다는 것이죠

컴퓨터 세계는 사람의 세계에서 보면 잔인하게 보이는 경우가 많습니다 자식이 사치를 한다고 죽이고 시킬일이 없다고 죽이고..
그냥 종료시키면 된다고 하면 될텐데 프로세스 죽일때 kill이라는 명시적인 표현을 쓰게 되죠

다음 시간에는 fork()와 exec()에 대해서 자세히 설명드리도록 하겠습니다


```