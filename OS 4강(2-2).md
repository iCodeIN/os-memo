#### 4강

```
(초반 설명은 이전이랑 겹쳐서 생략)

동기식 입출력 영어로 싱크로너스 아이오라고 합니다

여러분 사실 이 용어가 하나의 단어로 번역이 안돼요 동기식이라고 번역해놨지만 우리가 사실 동기식이라는 말을 쓰면서 살지 않았잖아요

영어는 싱크로너스라고 하면 감이 딱오는데 한국어로는 동기식이라고 하면 감이 안오기 때문에..

싱크라는거는 서로 맞추는거를 보통 싱크라고 불러요.. 시간적으로 맞추는거

싱크로나이즈드 스위밍하면 여러 선수가 동작을 맞추잖아요 시간적으로..
은행을 털러가는데 세명이 같이가요 그럼 몇초뒤에 경찰이 온다는게 보통 정해져있으니까
셋이 역할을 정하고 시간을 정해서 조율을 하죠.. 그런것도 싱크로너스라고 해요

아이오에서의 싱크로나이즈라고 한다면 아이오장치까지 직접가서 결과를 보고 오는거를 싱크로너스 동기식 입출력 이렇게 부를 수 있어요

이 아이오장치를 혼자 접근하는게 아니라 동시에 접근할 수 있는데
A는 아 장치에 갖다 쓰고 B는 여기서 읽어오고..
중간에 이제 직접 확인하지 않고 그냥 바로 다음일을 처리하면은 싱크로너스하지 않은 에이싱크로너스하다고 부르고

싱크로너스라는거는 아이오장치까지 가서 뭐가 적혀있는지를 직접 확인하고 읽어와서 그걸 보고 작업했다고 하면 싱크로너스 리드고
내가 아이오장치에 데이터를 쓰라고 해야되는데 써진걸 눈으로 확인ㄹ하고나서 그다음 작업을 실행하면 싱크로너스 라이트라고 하고

여기서 나오는 링크로너스랑 뒤에 또 프로세스 싱크로나이제이션이랑은 조금 의미가 다릅니다
그래서 정확히 설명 어렵지만 여기서는 일단 여기(ppt) 써있는걸로 이해하시면 될것 같은데요

- 동기식 입출력과 비동기식 입출력
* 동기식 입출력 (synchronous I/O)
    I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
    구현 방법 1
        I/O가 끝날 때까지 CPU를 낭비시킴
        매시점 하나의 I/O만 일어날 수 있음
    구현 방법 2
        I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
        I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
        다른 프로그램에게 CPU를 줌
* 비동기식 입출력 (asynchronous I/O)
    I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

※ 두 경우 모두 I/O의 완료는 인터럽트로 알려줌☆

----------------------------------------------------

(그림) 여기보시면 싱크로너스 아이오는 여기가 유저영역이고 여기가 커널 영역
아이오는 커널을 통해서만 할 수 있다고 말했었죠
그래서 사용자 프로그램이 아이오요청을 커널한테 하게되면 그거에 맞는 디바이스 드라이버 장치를 거치고 실제 하드웨어를 거쳐서 아이오를 쓰거나 읽는 작업을 하겠죠
근데 이게 조금 오래걸리는 작업입니다 그래서 좀 시간이 흘러야지만 아이오가 끝난거가 도착을 하고 이걸 보구서 사용자가 다ㅇㅁㅡ 작업을 한다
그러ㅡㅁ 이게 싱크로너스 아이오입니다 그동안 기다린거죠

그리고 이 에이싱크로너스 아이오는 사용자 프로그ㅗ램이 아이오 작업 요청을 운영체제 커널한테 해서 작업이 진행되겠죠
진행되는데 근데 이걸 기다리지 않고 아이오 요청만 해놓고 바로 씨피유 제어권을 얻어서 다른 작업들을 하는ㄱㅂ니다
이게 에이싱크로너스 아이오고 그런데 아이오가 시간이 걸렸을거고 끝나면 끝났다고 알려주게 되는데
아이오 작업이 끝나는건 인터럽트로 알려주게 됩니다

그럼 이 두개 아이오가 실제로 어떤 의미를 가지느냐, 예를 들어서 내가 하나의 프로ㅡ램을 짰는데 디스크에서 뭘 읽어와야해요
그럼 디스크에서 읽어오고 그다음을 하도록 프로그램을 자ㅈ겠죠
지금 내가 아이오 요청을 했으면 그 데이타를 장치에서 들고와야 다음작업을 할 수 있는게 보통이에요

그래서 리드.. 읽어오는 작업은 보통 기다려야하기 때문에 이 싱크로너스 아이오만 할 수 있는게 보통인거 같아요
그런데 그렇지 않게 프로그래밍 할 수도 있습니다 뭐냐면
내가 아이오 요청을 했지만 지금 아이오 결과나오는걸 보지 않고 즉 디스크에서 뭘 읽어오라고 했으면
읽어온 데이타랑 상관없이 그냥 처리할 수 있는 작업이 있을거에요
그동안 그 작업을 하도록 프로그램을 짤 수 있는거죠
그다음에 이제 아이오 끝났으면 읽어온 데이타를 알아야지만 할 수 있는걸 그때부터 하면 되는거니까

그런식으로 리드지만 에이싱크로너스하게 할 수 있는게 있고

라이트는 어떨까요
라이트는 에이싱크로너스하게 하는게 좀 자연스러워요
내가 스토리지에 데이터 쓰라고 하고 실제로 데이타 쓰든지 말든지 난 그다음 작업할 수 있습니다 보통
그렇지만 라이트는 싱크로너스하게 하고 싶을때가 있어요 정말 스토리지에 잘 썼는지 확인한다음에 내 프로그램 실행하ㄱ ㅗ싶다
그럼 싱크로너ㅡㅅ 라이트 하는겁니다 즉 아이오 요청하고 아이오가 끝나서 정말 끝났다는 인터럽트가 들어올때까지 기다렸다가 작업하는
구현하기 나름이죠..

근데 전시간에 어떤 설명을 드렸냐면 어떤 사용자 프로그램이 아이오 요청을 하면 그 아이오는 오래걸리는작업이라 그랬죠 그 오래걸리는 작업이 진행되는 동안에 이 친구가
씨피유 가지고 있으면서 아무것도 안하고 있으면 낭비죠
그래서 싱크로너스 아이오 요청한다음에 이 친구는 시피유 줘봐야 뭘 못하기 때문에 다른 프로세스한테 시피유 넘겨주게 됩니다
그거에 대해 설명한게 아까 보여드린 슬라이드에 써있던 구현 방법

그러다가 아이오 요청을 이제 던져놨기때문에 그 아이오가 언젠가 끝나면 그러면은 아이오 장치의 컨트롤러가 시피유한테 인터럽트를 걸겠죠 그러면 이제 시피유가 운영체제한테 잠시 넘어가서
아까 요청한 아이오가 끝났다는걸 알고 이제 이 친구한테 시피유를 줘도 되는 상황이 되는겁니다

그다음에 이제 DMA! 전 시간에 설명을 드렸던 부분인데요

- DMA (Direct Memory Access)
    빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
    CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송
    바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴

----------------------------------------------------------------

DMA는 메모리를 접근할 수 있는 장치죠 원래는 이 메모리를 접근할 수 있는 장치가 시피유밖에 없어요 그래서 아이오 장치들이 뭔가 시피유하고 통신을 교신을 해야할 때 인터럽트를 걸어주고

그럼 시피유가 아이오 작업 인풋 디바이스로부터 요청이 왔으면 여기있는 내용을 자기 메모리로 카피를 할거고 아웃풋 디바이스로 요청이 왔으면 이쪽으로 보내고 그렇겠죠

근데 키보드가 1바이트 입력하고 그럴때마다 인터럽트가 걸리면 너무 많이 인터럽트 걸리고 오버헤드가 뒤따르겠죠

그래서 DMA라는 장치를 하나 더 붙여놓고 이 메모리를 접근할 수 있는건 CPU만 그런게 아니라 DMA도 이제 직접 접근할 수 있도록 만들어놓습니다

그래서 이제 이 작은 일들은 버퍼에 블럭이라고 할 정도의 사이즈로 데이터가 쌓이면 그때 CPU한테 인터럽트를 한번 걸어주게 됩니다

그렇게하면 시피유가 인터럽트를 당하는 빈도가 조금 적어지고 그럼 더 효율적으로 시피유가 일을 할 수 있게 되는겁니다

그게 이제 DMA라는거죠

- 서로 다른 입출력 명령어
* I/O를 수행하는 special instruction에 의해
* Memory Mapped I/O에 의해
----------------------------------------------------------------

우리가 시피유에서 실행할 수 있는 기계어 인스트럭션에는 메모리만 접근하는 인스트럭션이 있고 아이오 장치를 접근해야되는 인스트럭션이 있어요
그래서 시피유에 있는 인스트럭션 중에서 메모리에 접근하는 인스트럭션이 이제 하나가 있고 로드 스토어 보통 이런 인스트럭션을 메모리 접근하는 인스트럭션이라고 부르고

각 아이오 디바이스 별로 아이오 디바이스를 접근하려면 로드 스토어 말고 별개의 인스트럭션이 정의되어 있어서 그런 인스트럭션으로 아이오 장치를 접근하는게 일반적입니다

그래서 메모리 주소가 있듯이 아이오 디바이스도 주소가 있습니다
(여기까지 일반적인 I/O 설명)

IO장치도 메모리 주소에 연장 주소를 붙인다음에 여기가 이제 백번지라고 할때 백번지에 대한 접근으 ㄹ하면 메모리
천번지에 하면 아이오를 하는 그런식으로 정의되어있는게 이제 memory mapped I/O라고 부르게 되구요
(여기까지 메모리 맵드 I/O 설명)

저장장치 계층 구조에 대해서 말씀드릴건데요 약간 하드웨어적인 부분을 설명드리는데
맨위에 사실 시피유가 있고 그 안에 레지스터라는게 있고 그다음에 캐시 메모리라는게 있습니다
이건 컴구에서 배울거고 운영체제는 약간의 언급

그다음에 디램으로 구성된 메인메모리가 있고
그다음에 요 아래 부분은 세컨더리 스테이지
요즘은 좀 달라지고 있죠 하드대신 플래시 메모리 쓰기도 하고..

이 계층 구조의 특징은 위로 갈수록 속도가 빨라지는 매체를 사용하고 있고
대신 단위당 가격이 비싸지기 때문에 위로 갈수록 용량이 적습니다.

그다음에 또 한가지 특징은 휘발성 매체냐 아니냐인데
테잎이나 디스크는 전원이 나가도 됩니다
반면에 디램이나 캐시로 사용되는 에스램이나 시피유 레지스터는 전원이 나가면 사라지게 됩니다 휘발생 매체라고 하는데

이제 보통 primary 계층이 휘발성 세컨더리 계층이 비휘발성
요즘은 또 조금 바뀌고 있긴 합니다만 메인메모리도 비휘발성 매체가 들어갈 수 있는 그런 새로운 반도체가 나오고 그런건 있지만 전통적으로는 메인 메모리 윗단은 휘발성
하드디스크부터 아랫단은 비휘발성으로 구성이 되고
시피유에서 접근 가능한 메모리를 이제 primary라고 부르고 실행 가능하다고 (Execututable) 부르고

시피유가 직접 접근해서 처리 못하는걸 세컨더리라고 부르고
시피유가 직접 접근하려면 바이트 단위로 접근가능한 매체여야 합니다
디램같은 경우는 바이트 단위로 주소를 매겨서 시피유가 접근 가능하고 바로 익스큐터블하게 되고

하드디스크 같은 경우는 바이트가 아니라 섹터단위 접근이죠 그래서 이제 요거는 익스큐터블 하지 않은 매체가 되겠습니다

아랫쪽에 있는 내용을 전부 위에 올려놓지는 못하겠죠? 그다음에 속도 차이가 난다고 말씀 드렸죠
밑으로 갈수록 느리고 위로 갈수록 빠릅니다
빠르면 씨피유가 인스트럭션을 원클락에 하나씩 처리하게 되는데 디램 메모리 접근하려면 뭐 적게는 십에서 많게는 백 클락 사이클까지 걸리니까 오래 걸리겠죠
그러한 속도 차이를 완충하기 위해서 캐시 메모리라는걸 두고 또 레지스터를 읽어들이고

캐시는 메인메모리보다 요ㅛㅇ량이 작죠 그래서 다 담지는 못하고 필요한것만 위로 올려서 쓰는데
그런걸 이제 우리가 캐싱이라는 용어로 부릅니다

* Caching : copying information into faster storage system

보통 캐싱은 재사용을 목적으로 하는거에요 처음 할때는 어쩔 수 없이 밑에서 위로 읽어들여서 시간이 걸리는데
그다음에 요청할때는 밑으로 안가고 같은거 읽어온거를 바로 읽어갈수가 있는겁니다 그게 바로 캐싱이라는 기법의 효과가 되겠습니다

근데 이 용량이 위로 갈수록 작아지기때문에 밑에서 모든걸 읽어들이지는 못하고 기존에 있던거중에 쫒아내야겠죠 새로운게 오면
그래서 그런걸 처리하는 방법도 주요 이슈입니다 뒤에가서 자세히 설명하게 될겁니다

자 그다음에 지금부터는 이제 프로그램이 컴퓨터에서 실행이 되는가 그것을 설명드리는 시간이 될겁니다
여기보시면 보통 프로그램이라는거는 실행파일 형태로 이 하드디스크에 저장이 되어있죠 파일 시스템에 파일형태로 ㅇㅇ
그러한 실행파일을 실행시키게 되면 메모리로 올라가서 프로세스가 됩니다
그래서 실행이 되는것인데요

정확히는 물리적인 메모리에 올라가게 되는게 아니고 한단계 거치는데 그게 이제 버추얼 메모리
가상 메모리라는 단계가 되겠습니다
그래서 어떤 프로그램을 실행시키게 되면 그 프로그램의 어드레스 스페이스 우리 말로 주소 공간이 형성이 되는데
메모리의 주소공간입니다

0번지부터 시작하는 그 프로그램의 독자적인 주소
즉 프로그램 A 실행하면 자기 자신만의 독자적인거 B도 마찬가지
그런 독자적인 주소 공간이 만들어지는데 이게 이제 코드 데이타 스택 (code/data/stack) 이렇게 나뉘어지는데
코드는 프로그램 기계어 코드 시피유에서 실행할 기계어 코드를 담고 있고
데이타는 변수나 전역변수라던지 프로그램이 사용하는 자료구조 담고 있구요
스택은 이 코드가 ㅏㅎㅁ수 구조로 되어있기 때문에 함수를 호출하거나 리턴할때 어떤 데이타 쌓아다가 꺼내가고 그런 용도로 사용하는게 스택 영역이라는 것이죠

그래서 모든 프로그램이 이 독자적인 주소 공간을 가지고 있는데 이 물리적인 메모리에 올려서 실행시키게 되는거죠

근데 이 커널은 처음 부팅하고 나면 메모리에 상주해서 올라가게 되ㅈ만
사용자 프로그램은 실행시키면 이 사용자 주소가 생겼다가 프로그램 종료시키면 사라지죠

근데 이 프로그램 실행시켰을 때 주소 공간을 다 메모리에 올리면 낭비라서 당장 필요한 부분 지금 뭐 A라는 함수 실행하고 있다고하면
거기에 해당하는 코드만 올려놓고 그렇지 않은건 올리지 않습니다 그래야만 메모리가 낭비되지 않겠죠
이제 사용 안하면 그걸 메모리에서 쫒아내고 경우에 따라서는 메모리에 올라와서 그냥 지워버리면 되지 않고 보관하고 있어야하는게 있을거에요
그 프로그램 종료전까지는 ㅇㅇ
그 이러한 주소공간에서 당장 필요한건 물리적 메모리에 올려놓고 그렇지 않은건 디스크에 내려놓게 됩니다
디스크에 특별하게 스왑 에어리어라는것에 내려놓는 것이죠

이게 그래서 실제로 연속적으로 할당된게 아니라 어떤건 여기에 어떤건 스왑에... 그런걸 버추얼 메모리라고 부르는것이죠

메인 메모리의 연장 공간으로 하드디스크 쓰는걸 이제 스왑핑. 뒤에 가면 우리가 배우게 될건데요

요걸 버추얼 메모리 기법이라고 부르기도 하지만 사실 버추얼 메모리 기법은 사용자 프로그램이 독자적으로 가지고 있는 영역을 버추얼 메모리라ㅗ 부르는것이죠

스왑으로 사용하는 하드디스크 공간은 전원이 나가면 거기있는 정보가 의미가 없고
그래서 스왑은 메모리 용량의 한계일때 연장해서 쓰는것이고..

물리적인 메모리도 사실 0번지부터 시작하는 구조에요 밑에서 올라가면서 주소가 증가하는데

뭐 그래서 여기서는 3천인데 여기서는 천번일 수 있어요 그래서 주소를 바꿔야되는데
주소 변환이라고 합니다 그걸 해주는 주소 변환 계층이 있는데요

근데 그거는 운영체제가 할 수 있는건 아니구요 하드웨어의 ㅈ원을 받아서 주소 변환해주는 하드웨어 장치가 있어요 그건 메모리 관리 부분에서 배우게 될겁니다

운영체제 커널도 사실 하나의 프로그램이기 때문에 코드 데이타 스택으로 분류되어있구요

- 커널 주소 공간의 내용☆
* code
    커널 코드
        시스템콜, 인터럽트 처리 코드
        자원 관리를 위한 코드
        편리한 서비스 제공을 위한 코드
    data
        PCB (Process Control Block)
        cpu, mem, disk
    stack
        Process A, B, C, ..의 커널 스택


커널에는 무슨 코드가 있을까요? 운영체제가 무슨 일을 해야하나요? 자원을 효율적으로 관리해야하니 그런 코드가 있을거고 사용자에게 편리한 인터페이스 제공해야되니 그런 코드가 있을거고
또 다른 말로 설명하면 운영체제라는거는 이제 언제 시피유를 얻게되느냐 하면 인터럽트가 들어오면 시피유 얻게 됩니다
각각 인터럽트마다 무슨 처리를 해야되는지 커널에 함수형태로 구현되어있을겁니다
시스템 콜이나 하드웨어가 발생시키는 인터럽트에 대해서 무슨 일을 해야할지 커널 코드부분에 들어있게 되구요
데이타 영역은 운영체제가 사용하는 여러가지 자료구조들이 정의되어있겠죠
운영체제가 cpu,mem,disk같은 하드웨어를 직접 관리하고 통제하겠죠 그 각각의 자료구조를 추상적으로 표현해놓은겁니다 (그림 내용이))
그리고 운영체제가 프로세스들을 관리하잖아요 현재 실행중인 프로그램을 관리해야되기 때문에 이걸 관리하기 위한 자료구조가 필요하겠죠
그걸 우리가 PCB라고 부릅니다 프로세스 컨트롤 블럭이라고 해서 시스템 안에 프로그램이 하나 돌아가면 그 프로그램을 관리하기 위한 그런 자료구조가 운영체제 커널에 하나씩 만들어지는데
그게 이제 PCB라는 거죠 프로세스마다 하나씩 만들어져서 관리를 하고 있게 됩니다

운영체제도 이제 함수 구조로 코드가 짜여져 있기 때문에 그걸 호출할 때 이제 스택 영역이 필요하게 됩니다
그리고 사용자 프로그램마다 커널 스택을 별도로 두고 있습니다 이것도 뒤에서 다시 설명드릴 기회가 있을겁니다

- 사용자 프로그램이 사용하는 함수
* 함수 (function)
    사용자 정의 함수
        자신의 프로그램에서 정의한 함수
    라이브러리 함수
        자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
        자신의 프로그램의 실행 파일에 포함되어 있다

    커널 함수
        운영체제 프로그램의 함수
        커널 함수의 호출 = 시스템 콜

※ 사용자 정의 함수, 라이브러리 함수 -> 프로세스 A의 Address space
※ 커널 함수 -> Kernel Address space


프로그램의 실행 과정 : 유저 모드 -> 커널 모드 -> 유저 모드 -> 커널 모드 왔다갔다의 과정들...