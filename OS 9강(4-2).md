```

Copy-on-write (COW)
* 프로세스 생성 (Process Creation)
- 부모 프로세스(Parent Process)가 자식 프로세스(Children Process) 생성
- 프로세스의 트리(계층 구조) 형성
- 프로세스는 자원을 필요로 함
    - 운영체제로부터 받는다
    - 부모와 공유한다
- 자원의 공유
    - 부모와 자식이 모든 자원을 공유하는 모델
    - 일부를 공유하는 모델
    - 전혀 공유하지 않는 모델
- 수행 (Execution)
    - 부모와 자식은 공존하며 수행되는 모델
    - 자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델

- 주소 공간(Address space)
    - 자식은 부모의 공간을 복사함 (binary and OS data)
    - 자식은 그 공간에 새로운 프로그램을 올림
- 유닉스의 예
    - fork() 시스템 콜이 새로운 프로세스를 생성
        - 부모를 그대로 복사 (OS data except PID + binary)
        - 주소 공간 할당
    - fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 메모리에 올림

-------------------------------------------------------------------------------------

오늘은 fork와 exec 시스템 콜의 실제 코드 (이걸 사용해서 사용자가 프로세스 만드는 코드)를 보여드릴까 합니다

* A process is created by the fork() system call.
    - creates a new address space that is a duplicate of the caller.

```
```C
/* fork() 시스템 콜 */
int main() {
    int pid;
    pid = fork();
    if (pid == 0) { /* this is child */
        printf("\n Hello, I am child!\n");
    }

    else if (pid > 0) { /* this is parent */
        printf("\n Hello, I am parent!\n");
    }
}
```
```

여기보시면 이제 c언어 코드가 하나 소개 되어있죠
메인함수가 시작되고 있고 여기보시면 빨간색으로 fork라는 함수를 호출하고 있는데 이게 바로 시스템 콜입니다
운영체제한테 새로운 프로세스를 하나 만들어달라는 그런 요청인것이죠

우리가 보통 함수르 ㄹ호출하게 되면, 그 함수에 해당하는 기능을 수행하고
그다음에 이제 그 함수가 끝나면 뭔가 필요한 리턴 밸류를, 결과값을 반환하고
그다음 나와 있는 코드를 계속 수행하게 되죠
이 fork 시스템콜도 마찬가지입니다 그런데 조금 이제.. 그전에 순차적으로 실행하는 코드에만 익숙하시면 fork의 결과.. 프로세스가 하나 생성되는 이 부분이 익숙하시지 않을수가 있습니다
어떻게 생각하는게 편하냐면, 이 코드를 하나 카피해서 옆에 붙여놓고 보는겁니다
그런다음에 일단 처음에는 이 프로그램 (왼쪽) 하나입니다 부모가 아직 자식 안낳은 상태 ㅇㅇ
얘가 진행하다가 fork를 만나서 자식 프로세스를 하나 생성합니다 그럼 옆에 하나 생기게 되는 겁니다
이 함수 실행 끝났으면 부모 프로세스는 아무 일 없다는듯이 밑에 코드 마저 실행하고,

자식 프로세스는 새로 하나 만들어졌습니다, 그런데 이게 메인 함수의 시작부분부터 실행하는게 아니라 fork의 실행 시점 이후부터 코드가 실행되는겁니다
(이거 중요!)

부모 프로세스의 문맥을 컨텍스트를 그대로 복사한다고 말씀드렸죠
그러니 부모 입장에서는 프로그램 카운터가 여기를 가르키고 있다고 말했을겁니다 (fork부분)

그런데 자식이 이제 이걸 카피를 하니까, 방금전에 fork를 했구나 (내가 아니고 부모가 했구나)
자식은 방금전까진 fork까지 실행됐구나라는 기억을 가지고 코드를 실행하게 되는겁니다

예전에 이런 식으로 코드가 있으면 포크가 무한대로 발생하겠네요? 라는 질문이 있었는데 아주 좋은 질문입니다 포크의 작동 방식에 대해서 잘 알게될 수 있는 질문이죠

이걸 (포크에 대해 설명한 내용들을) 정확하게 이해하셔야겠습니다

이제 문제가 이 친구(자식)가 자신이 원본이라고 주장하는거죠 그러면서 부모를 복제본 취급 하는거죠 그러면 상당히 혼란스러운... 상황이 생기게 되는데
그게 하나 문제가 되겠구요

그다음에 포크를 하게 되면 부모랑 똑같은게 만들어지게 되니까 세상에 있는 프로그램들은 모두가 그 똑같은... 제어흐름을 따라가야할거 같고
이런것들이 포크를 했을때 생각할 수 있는 두가지 문제점이 되겠죠


그런데 운영체제가 프로세스를 복제해서 자식을 만들어주게 되면, 자식과 부모를 구별을 해줍니다
어떻게 구분하느냐? 하면 포크라는 함수의 리턴밸류, 즉 결과값이 다릅니다
포크하고 나면 부모에서는 결과값이 양수가 얻어집니다. 정확하게 말하면 자식프로세스의 PID, 주민등록번호를 얻게 되어서 양수고
자식 프로세스는 포크를 한 결과값으로 0을 받습니다.

그래서 서로 내가 원본이고 복제본이다 구분할 수가 있는것이죠
그래서 이렇게 포크의 리턴밸류 다르기 때문에 부모 프로세스하고 자식 프로세스는 다른 일을 하게 할 수 있겠죠

그래서 포크의 결과값이 0이면 이걸 실행하고, 0이 아니면 저걸 실행하게 하라고 했을때
부모는 양수니까 밑에꺼를 실행하겠죠 그래서 hello i am parent 출력하게 될거구요

자식은 fork의 결과값이 0이니까 if문 첫번째꺼를 만족해서 hello i am child 출력하고 그다음꺼는 건너뛰게 되겠죠

이런식으로 부모랑 자식에게 다른 일을 시킬 수가 있죠 그걸 지금 설명 드렸습니다.

그다음에 여기는 써있지 않지만, 다른 코드들이 포함되어있다고 한번 해보죠

```
```C
int main() {
    int pid;
    printf("\n Hello, I am child!\n"); /* 새로 추가한 코드 */
    pid = fork();
    if (pid == 0) { /* this is child */
        printf("\n Hello, I am child!\n");
    }

    else if (pid > 0) { /* this is parent */
        printf("\n Hello, I am parent!\n");
    }
}
```
```

자 이러면 부모 프로세스가 시작하면서 이 구문을 출력하게 될거고, 그다음에 포크를 하죠
그럼 자식 프로세스는 프로그램 카운터가 이 부분(`pid = fork();`) 가리키고 있으니까
'아 여기까지 과거에 실행했을거야'라는 기억을 가지고 있죠?
하지만 실제로 실행한건 아니죠 부모가 실행한거니까..

어쨌든 자식은 해당 구문을 실행하지 않고 fork 아래에 있는 구문들만 실행하게 됩니다

이렇게 되면은 어쨌든 세상에 같은 그 코드를 가지는 실제로 제어흐름에서는 다른 브랜치로 나아갈 수 있지만
같은 흐름을 가지는 코드만 존재할텐데.. 실제로는 그렇지 않고 다른 프로그램들을 실행시킬 수 있어야겠죠

그래서 존재하는 시스템콜이 exec 시스템콜이라는겁니다
exec 시스템콜은 어떤 프로그램을 완전히 새로운 프로세스로 태어나게 해주는 그런 역할을 해줍니다

그래서 여기 코드를 보시면, 일단 fork를 해서 자식 프로세스를 하나 만들었죠
그런다음에, 부모 프로세스라면 화면에 이걸 출력하도록 하고 자식 프로세스는 화면이 이걸 출력하게 한다음에 execlp 함수를 실행하게 합니다
```
```C
int main() {
    int pid;
    pid = fork();
    if (pid == 0) { /* this is child */
        printf("\n Hello, I am child! Now I`ll run date \n");
        execlp("/bin/date", "/bin/date", (char *) 0);
    }
    else if (pid > 0) { /* this is parent */
        printf("\n Hello, I am parent!\n");
    }
}
```
```

execlp는 일종의 함수인데, 이 함수가 결국은 exec 시스템콜을 하게 됩니다 그래서 exec 시스템콜은 지금 이런 프로그램, 이런 코드를 가진 프로그램이 실행이 되다가
exec 시스템콜을 만나게 되면 요런 기억은 완전히 잊어버리고, 여기 이제 소개되는 새로운 프로그램으로 완전히 덮어씌우는 겁니다

예를 들어 지금까지는 이렇게 살았지만, exec을 해주는 센터에 가서 exec을 딱 하게 되면 저는 완전히 새로운 사람으로 살게되는것인데

exec을 하면 이 프로그램(exec으로 실행하는거)의 메인 함수부터 새로 실행하게 됩니다

아까처럼 두개를 띄워놓고, 이 오른쪽에 있는거가 /bin/date의 코드다 그러면 자식 프로세스는 화면의 printf에 이 문자를 출력한다음에 date라는 새로운 프로그램으로 덮어써서 실행하고
date 실행이 끝나면 본인의 운명이 다하게 되는거죠
exec를 하면, 되돌아 올 수 없습니다. exec으로 새로 태어나면 다시 돌아갈 수 없고 그냥 거기서 살아야되는겁니다

지금 소개해드린 코드는, 그 자식 프로세스를 포크한다음에 자식에게 완전히 새로운 프로그램을 덮어씌우기 위해서 exec을 한것이죠
그렇지만 꼭 exec이라는게 자식을 만들어서 exec 해야되는건 아닙니다 사실은.

여기서 아예 fork를 빼버리고, 이런식으로 프로그래밍을 할 수도 있어요

```
```C
int main() {
    printf("\n Hello, I am child! Now I`ll run date \n");
    execlp("/bin/date", "/bin/date", (char *) 0);
    printf("\n Hello, I am parent!\n");
}
```
```

여기는 이제 fork가 없죠 이 프로그램 실행하면, hello i am child를 출력합니다
그다음에 exec 했기 때문에 이제 이걸 완전히 잊어버리고, date 실행 시켜서 date의 메인 함수 시작부터 맨끝까지 실행하게 될겁니다

그러므로 exec 밑에 있는 이 코드는 실행이 불가능합니다 이미 덮어써버렸으니까, 영원히 실행이 안되는 코드라는것이죠

이 date라는 프로그램이 여러분들 조금 익숙하지 않다면은, 이런 printf 해가지고 그냥 1을 출력하고
프로그램중에서 echo라는 커맨드가 있습니다 뒤에 나오는 argument를 화면에 그대로 출력해주는겁니다

C언어에서 printf라는 문장하고 유사하다고 생각하심 되는데 예를 들어
```
```C
int main() {
    printf("1");
    execlp("echo", "echo", "3", (char *) 0);
    printf("2");
}
```
```

1이 출력이 되고, echo라는 프로그램으로 덮어써서 3이라는 문구가 출력되고 종료가 됩니다.
2는 영원히 출력이 안되겠죠.

execlp에는 echo를 이런식으로 실행시키는데, 실제로 리눅스의 쉘 환경에서는..
echo 3하고 엔터를 치면 화면에 3이 출력이 됩니다. 또는 echo 하고서 hello 3 이렇게하면 화면에 hello 3이 출력이 되고.
echo는 이 뒤에 나오는 아규먼트를 출력해주는 리눅스 커맨드에요

그런데 이런 커맨드를 exec로 실행시키려면 execlp에다가 프로그램 이름을 두번 써주고, 콤마로 구분해서 따옴표 안에 아규먼트를 순차적으로 넣어주고 마지막에는 항상 캐릭터 포인터 0을 적어주게 됩니다

이렇게 해서 fork랑 exec 두개의 시스템 콜 말씀드렸구요

