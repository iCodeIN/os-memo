```
이번 시간에는 CPU 스케줄링 설명드리겠습니다.

컴퓨터 프로그램이 실행될때는, 이와같은 단계를 거칩니다.
즉, CPU에서 인스트럭션을 실행하는 단계와 오래걸리는 IO 작업을 하는 단계.
이런 일련의 단계를 번갈아가면서 실행하는게 모든 프로그램의 실행에서 거치게 되는 경로입니다.
물론 프로그램 종류마다 조금씩 다르죠. IO가 빈번히 끼어들지 않는 그런 프로그램의 경우는
CPU에서 인스트럭션 실행하는 단계. 우리가 그걸 CPU 버스트라고 부르죠. 그게 굉장히 길게 나타날것이구요.
거기에 비해서 사람하고 인터랙션하는 프로그램인 경우 중간중간 화면 출력 나가고 키보드 입력받고 그러기 때문에
중간에 IO가 끼어들게 됩니다. 자연스럽게 시피유 연속적으로 쓰는 단계가 짧아지게 되겠죠.
연속적으로 쓰는 시간을 그래프로 뽑아보면, 이렇게 CPU 버스트가 짧은 경우가 빈번하고 굉장히 긴 경우도 간혹가다 나타난다는 것이죠.

컴퓨터 시스템에서 돌아가는 프로그램은 모두 동일한 패턴을 가지는 것이 아니고, 긴 경우랑 짧은 경우가 섞여 있는 것이죠.
그래서 CPU 스케줄링이라는게 필요한겁니다.
이런 잡 (사용자와 인터랙션 하는)에게 CPU가 너무 늦게 돌아가면, 응답시간이 늦어져서 사람이 좀 오래기다려야 되기 때문에 답답한 거죠.
그래서 cpu 스케줄링이라는 것은 레디큐에 들어와있는, 즉 시피유를 얻고자 하는 프로세스 중에서 어떤 프로세스한테 시피유를 줄것인지를
결정하는 그런 매커니즘이 시피유 스케줄링인데요.

크게 두가지 이슈가 있죠. 하나는, 이런 시피유 버스트에 들어온 프로그램이 여럿이 있는데 누구한테 당장 먼저 시피유를 줄것인가에 대한 문제.
또 하나는, 이 프로그램에게 시피유 줬으면 IO 하러 나갈때까지 시피유를 계속 주느냐. 아니면 CPU 버스트가 너무 길기 때문에 중간에 시피유를 뺏어서
다른 프로세스한테 시피유를 넘겨주느냐.

즉, 누구한테 줘야할지 결정해야하고 일단 줬으면 계속 쓰게 할것인지 중간에 시피유를 뺏어올수도 있게 할것인가. 이게 시피유 스케줄링에서 중요한 두가지 이슈가 되겠습니다.
특히 두번째 이슈, 시피유 주고나서 뺏지 않고 다 쓰고 나갈때까지 보장해준다고 하면.. 예를 들어서 시피유 버스트 굉장히 긴 이런 프로그램한테 시피유 한번
넘어가게 되면 그 뒤에 도착하는 IO바운드 잡들. 시피유 좀만 주면 바로 쓰고 나갈 프로그램인데도 불구하고 긴 프로세스 하나가 시피유 잡고 안내놓으면 이 친구들은
줄서서 오래 기다려야 하는거죠. 그래서 지나치게 오래 기다리지 않는 방향으로 가야된다는 것이 중요하겠습니다.

그래서 지금 말씀드린대로 시피유 스케줄링 알고리즘이 여러가지 소개가 될텐데요, 크게 두가지로 나누어보면 하나는 nonpreemptive한 스케줄링이고. 즉 강제로
시피유 빼앗지 않는 방법. 일단 한번 줬으면 그 프로그램이 다 쓰고 나갈때까지 이 친구한테 시피유 보장해주는 방법. 우리말로는 이것을 비선점형이라고 합니다.

그다음에 강제로 빼앗을 수 있는 방법. 프로그램이 계속 시피유 쓰고 싶지만 강제로 빼앗을 수 있는.. 타이머라는 하드웨어 두고 인터럽트 해서 뺏을 수 있다는건 이미 설명드렸습니다. 현대적인 시피유 스케줄링은 사실... preemptive한.. 선점형 스케줄링을 거의 쓰고 있습니다.
그래서, 지금부터 소개해드릴 시피유 스케줄링들은 크게 비선점형, 선점형. 두가지 방법으로 나뉘게 됩니다.

```

### Scheduling Algorithms
* FCFS (First-Come First-Served)
* SJF (Shortest-Job-First)
* SRTF (Shortest-Remaining-Time-First)
* Priority Scheduling
* RR (Round Robin)
* Multilevel Queue
* Multilevel Feedback Queue

```
그러면, 스케줄링 알고리즘이 어떤게 좋은지 평가할 수 있는 성능 척도가 필요할텐데요. Scheduling Criteria라고 부르고. 또 일반적으로 성능을 측정할 수 있는 방법을 퍼포먼스 인덱스. 퍼포먼스 매져. 이렇게 부르기도 합니다.

```

### Scheduling Criteria (Performance Index)
* CPU utilization (이용률)
    * keep the CPU as busy as possible
* Throughput (처리량)
    * # of processes that complete their execution per time unit
* Turnaround time (소요시간, 반환시간)
    * amount of time to execute a particular process
* Waiting time (대기 시간)
    * amount of time a process has been waiting in the ready queue
* Response time (응답 시간)
    * amount of time it takes from when a request was submitted until the first response is produced, not output
    (for time-sharing environment)

```
여러가지가 있는데 이걸 또 크게 두가지로 분류 할 수 있습니다.
하나는 시스템 입장에서의 성능척도입니다. 나머지 하나는 프로그램 입장에서의 성능척도입니다.
시스템 입장에서의 성능척도라는거는, 시피유 하나 가지고 일을 최대한 많이 시키면 좋은거겠죠.
이용률, 쓰루풋 이렇게 두가지로 이야기하게 되고.
프로그램, 프로세스 입장에서의 성능척도는 내가 시피유를 빨리 얻어서 빨리 끝나면 좋은거죠.
그래서 시간을.. 얼마나 빨리 처리할 수 있느냐. 그런 척도를 세가지로 세분화해서 얘기하게 됩니다.

맨위에 나와있는 시피유 이용률이라는건, 전체 시간중에서 시피유가 놀지 않고 일한 시간의 비율을 나타냅니다.
여기 써있는 표현대로 살펴보자면 시피유는 가능한, 바쁘게 일을 시켜라 이말이죠.
시피유라는건 굉장히 비싼자원이기 때문에 놀리지 말고 최대한 일을 시켜서 이런 비율을 높게 하는것이 시피유 입장에서 시피유를 잘쓰는 방법이라는거죠.
두번째로 나와있는 쓰루풋. 이건 처리량 산출량 이렇게 얘기하는데 주어진 시간동안 과연 몇개의 일. 몇개의 작업을 완료했느냐. 그걸 나타내는거죠
주어진 시피유를 이용해서 가능하면 더 많은 일을 처리하는것이 좋겠죠.

그다음에 밑에 이 세가지는, 고객 입장. 시피유 스케줄링이기 때문에 프로세스 입장에서의 성능척도입니다. 가능하면 내가 빨리 서비스를 받고, 여기서 인제 기다리다가.. 시피유 버스트 하기 위해서 들어와서 기다리다가.. 시피유 빨리 잡아서 쓰고 아이오 하러 나가고 싶겠죠.
프로세스 입장에서의 성능 척도라는건 시간이 빨리 처리되는게 중요한데 그걸 세가지로 나눈겁니다.
첫번째로 턴 어라운드 타임. 소요시간 반환시간 이런 표현 쓰더라구요. 좀 헷갈리기 때문에 턴 어라운드 타임이라는 표현을 쓰겠습니다.
턴 어라운드 타임이라는거는 시피유를 쓰러 들어와서, 다 쓰고 나갈때까지 걸린 시간을 말하는겁니다.
그다음에 웨이팅 타임은, 기다린 시간을 의미합니다. 즉, 시피유를 쓰고자하더라도 하나밖에 없기 때문에 레디큐에 줄서서 기다리겠죠.
그 순수하게 기다린 시간을 웨이팅 타임이라고 하고, 본인이 실제로 러닝을 한 시간을 합친건 턴 어라운드 타임이구요.
그 다음에 마지막으로 이 리스폰스 타임. 응답시간이라는 것이 있는데, 이 레디큐에 들어와서 (시피유 쓰겠다고 들어와서) 처음으로 시피유 얻는데 걸린 시간입니다. 이게 웨이팅 타임이랑 어떻게 다른지 구분해서 설명해드리자면 선점형 스케줄링은 시피유 한번 얻었다고 해서 끝까지 쓰는게 아니죠.
계속 줄서서 기다리고 받아서 쓰고 반복되는데.. 그 기다린 시간을 다 합친 개념이 웨이팅 타임이고. 리스폰스 타임이라는 것은 최초의 CPU 얻기까지 기다린 시간을 말하는 것이죠.



```